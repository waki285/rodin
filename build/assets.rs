use anyhow::{anyhow, Result};
use lightningcss::stylesheet::{MinifyOptions, ParserOptions, PrinterOptions, StyleSheet};
use lightningcss::targets::{Browsers, Targets};
use regex::Regex;
use serde_json::json;
use sha2::{Digest, Sha256};
use std::{collections::HashMap, fs, path::PathBuf, process::Command};

/// Minify a JavaScript file with esbuild and return the minified content
fn minify_js(src_path: &PathBuf) -> Result<String> {
    let tmp_dst = src_path.with_extension("js.tmp");
    let esbuild = Command::new("node_modules/.bin/esbuild")
        .args([
            src_path.to_string_lossy().as_ref(),
            "--platform=browser",
            "--charset=utf8",
            "--minify",
            "--legal-comments=none",
            "--drop:console",
            "--tree-shaking=true",
            format!("--outfile={}", tmp_dst.to_string_lossy()).as_ref(),
        ])
        .output();

    let out = esbuild.map_err(|err| {
        anyhow!(
            "esbuild not run for {}: {err}. Ensure node_modules/.bin/esbuild exists.",
            src_path.display()
        )
    })?;

    if !out.status.success() {
        return Err(anyhow!(
            "esbuild failed for {} (status {}): {}",
            src_path.display(),
            out.status,
            String::from_utf8_lossy(&out.stderr)
        ));
    }

    let content = fs::read_to_string(&tmp_dst)?;
    fs::remove_file(&tmp_dst)?;
    Ok(content)
}

/// Minify a JS file, hash it, write to out_dir, and return the hashed filename
fn process_js_file(
    src_path: &PathBuf,
    out_dir: &PathBuf,
    stem: &str,
    manifest_key: &str,
    manifest: &mut HashMap<String, String>,
    content_transform: Option<impl FnOnce(String) -> String>,
) -> Result<Option<String>> {
    if !src_path.exists() {
        return Ok(None);
    }

    let mut content = minify_js(src_path)?;

    // Apply optional transformation (e.g., replacing paths)
    if let Some(transform) = content_transform {
        content = transform(content);
    }

    let hash = short_hash(content.as_bytes());
    let hashed_name = format!("{}-{}.js", stem, hash);
    fs::write(out_dir.join(&hashed_name), &content)?;
    manifest.insert(
        manifest_key.to_string(),
        format!("/assets/build/{}", hashed_name),
    );

    Ok(Some(hashed_name))
}

pub fn minify_assets() -> Result<()> {
    let out_dir = PathBuf::from("static/build");
    fs::create_dir_all(&out_dir)?;

    let targets = browserslist_targets()?;
    let mut manifest: HashMap<String, String> = HashMap::new();

    // Step 1: Hash and rename font files (generated by fonts.rs) - only woff2, not ttf
    // Do this FIRST so we can replace font paths in CSS
    let re_font = Regex::new(r"^IBMPlexSansJP.*\.subset\.woff2$").unwrap();
    let mut font_replacements: HashMap<String, String> = HashMap::new();
    for entry in fs::read_dir(&out_dir)? {
        let p = entry?.path();
        if let Some(fname) = p.file_name().and_then(|s| s.to_str()) {
            if re_font.is_match(fname) {
                let bytes = fs::read(&p)?;
                let hash = short_hash(&bytes);
                let (stem, ext) = split_name(fname);
                let hashed_name = format!("{}-{}.{}", stem, hash, ext);
                let hashed_path = out_dir.join(&hashed_name);
                // rename original to hashed
                fs::rename(&p, &hashed_path)?;
                let old_path = format!("/assets/build/{}", fname);
                let new_path = format!("/assets/build/{}", hashed_name);
                font_replacements.insert(old_path.clone(), new_path.clone());
                manifest.insert(old_path, new_path);
            }
        }
    }

    // Step 2: Process CSS files, replacing font paths with hashed versions
    let css_dir = PathBuf::from("static/css");
    fs::create_dir_all(&css_dir)?;
    for entry in fs::read_dir(&css_dir)? {
        let path = entry?.path();
        if path.extension().and_then(|s| s.to_str()) != Some("css") {
            continue;
        }
        let file_name = match path.file_name() {
            Some(name) => name.to_owned(),
            None => continue,
        };
        let file_str = file_name.to_string_lossy();
        let content = fs::read_to_string(&path)?;
        let mut min = minify_css_with_prefix(&content, targets).unwrap_or_else(|err| {
            eprintln!(
                "warning: failed to minify {} with lightningcss: {err}",
                file_str
            );
            content.clone()
        });

        // Replace font paths with hashed versions
        for (old_path, new_path) in &font_replacements {
            min = min.replace(old_path, new_path);
        }

        // compute hash of final CSS (with replaced font paths) and write
        let hash = short_hash(min.as_bytes());
        let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or("style");
        let hashed_name = format!("{}-{}.css", stem, hash);
        fs::write(out_dir.join(&hashed_name), min)?;
        manifest.insert(
            format!("/assets/build/{}", file_str),
            format!("/assets/build/{}", hashed_name),
        );
    }

    // Step 3: Process home.js first so we can replace references in app.js
    let home_js_hashed = process_js_file(
        &PathBuf::from("static/home.js"),
        &out_dir,
        "home",
        "/assets/build/home.js",
        &mut manifest,
        None::<fn(String) -> String>,
    )?;

    // Step 4: Process app.js, replacing home.js reference with hashed version
    let home_js_hashed_clone = home_js_hashed.clone();
    process_js_file(
        &PathBuf::from("static/app.js"),
        &out_dir,
        "app",
        "/assets/build/app.js",
        &mut manifest,
        Some(move |content: String| {
            if let Some(ref hashed) = home_js_hashed_clone {
                content.replace(
                    "/assets/build/home.js",
                    &format!("/assets/build/{}", hashed),
                )
            } else {
                content
            }
        }),
    )?;

    // Step 5: Process twitter.js (lazy loader for embeds)
    process_js_file(
        &PathBuf::from("static/twitter.js"),
        &out_dir,
        "twitter",
        "/assets/twitter.js",
        &mut manifest,
        None::<fn(String) -> String>,
    )?;

    // write manifest
    let gen_dir = PathBuf::from("static/generated");
    fs::create_dir_all(&gen_dir)?;
    let manifest_path = gen_dir.join("assets-manifest.json");
    fs::write(
        manifest_path,
        serde_json::to_string_pretty(&json!(manifest))?,
    )?;

    Ok(())
}

fn browserslist_targets() -> Result<Targets> {
    let browsers = Browsers::from_browserslist(vec!["> 0.5%", "not dead"])?.unwrap_or_default();
    Ok(browsers.into())
}

fn minify_css_with_prefix(content: &str, targets: Targets) -> Result<String> {
    let mut sheet =
        StyleSheet::parse(content, ParserOptions::default()).map_err(|e| anyhow!(e.to_string()))?;

    sheet
        .minify(MinifyOptions {
            targets,
            ..Default::default()
        })
        .map_err(|e| anyhow!(e.to_string()))?;

    let res = sheet
        .to_css(PrinterOptions {
            minify: true,
            targets,
            ..Default::default()
        })
        .map_err(|e| anyhow!(e.to_string()))?;

    Ok(res.code)
}

fn short_hash(bytes: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(bytes);
    let res = hasher.finalize();
    hex::encode(res)[..12].to_string()
}

fn split_name(name: &str) -> (String, String) {
    if let Some(pos) = name.rfind('.') {
        let (a, b) = name.split_at(pos);
        (a.to_string(), b.trim_start_matches('.').to_string())
    } else {
        (name.to_string(), String::new())
    }
}
