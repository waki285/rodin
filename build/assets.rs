use anyhow::{anyhow, Result};
use lightningcss::stylesheet::{MinifyOptions, ParserOptions, PrinterOptions, StyleSheet};
use lightningcss::targets::{Browsers, Targets};
use regex::Regex;
use sha2::{Digest, Sha256};
use serde_json::json;
use std::{fs, path::PathBuf, process::Command, collections::HashMap};

pub fn minify_assets() -> Result<()> {
    let out_dir = PathBuf::from("static/build");
    fs::create_dir_all(&out_dir)?;

    let targets = browserslist_targets()?;

    let css_dir = PathBuf::from("static/css");
    fs::create_dir_all(&css_dir)?;
    let mut manifest: HashMap<String, String> = HashMap::new();
    for entry in fs::read_dir(&css_dir)? {
        let path = entry?.path();
        if path.extension().and_then(|s| s.to_str()) != Some("css") {
            continue;
        }
        let file_name = match path.file_name() {
            Some(name) => name.to_owned(),
            None => continue,
        };
        let file_str = file_name.to_string_lossy();
        let content = fs::read_to_string(&path)?;
        let min = minify_css_with_prefix(&content, targets).unwrap_or_else(|err| {
            eprintln!(
                "warning: failed to minify {} with lightningcss: {err}",
                file_str
            );
            content.clone()
        });
        // compute hash and write to hashed filename
        let hash = short_hash(min.as_bytes());
        let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or("style");
        let hashed_name = format!("{}-{}.css", stem, hash);
        fs::write(out_dir.join(&hashed_name), min)?;
        manifest.insert(format!("/assets/build/{}", file_str), format!("/assets/build/{}", hashed_name));
    }

    // Process home.js first so we can replace references in app.js
    let mut home_js_hashed: Option<String> = None;
    let home_src = PathBuf::from("static/home.js");
    if home_src.exists() {
        let tmp_dst = out_dir.join("home.js.tmp");
        let esbuild = Command::new("node_modules/.bin/esbuild")
            .args([
                home_src.to_string_lossy().as_ref(),
                "--platform=browser",
                "--charset=utf8",
                "--minify",
                "--legal-comments=none",
                "--drop:console",
                "--tree-shaking=true",
                format!("--outfile={}", tmp_dst.to_string_lossy()).as_ref(),
            ])
            .output();

        let out = esbuild.map_err(|err| {
            anyhow!("esbuild not run for home.js: {err}. Ensure node_modules/.bin/esbuild exists.")
        })?;

        if !out.status.success() {
            return Err(anyhow!(
                "esbuild failed for home.js (status {}): {}",
                out.status,
                String::from_utf8_lossy(&out.stderr)
            ));
        }
        let bytes = fs::read(&tmp_dst)?;
        let hash = short_hash(&bytes);
        let hashed_name = format!("home-{}.js", hash);
        fs::rename(&tmp_dst, out_dir.join(&hashed_name))?;
        manifest.insert("/assets/build/home.js".to_string(), format!("/assets/build/{}", hashed_name));
        home_js_hashed = Some(hashed_name);
    }

    // Process app.js, replacing home.js reference with hashed version
    let app_src = PathBuf::from("static/app.js");
    if app_src.exists() {
        let tmp_dst = out_dir.join("app.js.tmp");
        let esbuild = Command::new("node_modules/.bin/esbuild")
            .args([
                app_src.to_string_lossy().as_ref(),
                "--platform=browser",
                "--charset=utf8",
                "--minify",
                "--legal-comments=none",
                "--drop:console",
                "--tree-shaking=true",
                format!("--outfile={}", tmp_dst.to_string_lossy()).as_ref(),
            ])
            .output();

        let out = esbuild.map_err(|err| {
            anyhow!("esbuild not run for app.js: {err}. Ensure node_modules/.bin/esbuild exists.")
        })?;

        if !out.status.success() {
            return Err(anyhow!(
                "esbuild failed for app.js (status {}): {}",
                out.status,
                String::from_utf8_lossy(&out.stderr)
            ));
        }

        // Replace home.js reference with hashed version
        let mut content = fs::read_to_string(&tmp_dst)?;
        if let Some(ref hashed) = home_js_hashed {
            content = content.replace("/assets/build/home.js", &format!("/assets/build/{}", hashed));
        }

        // Compute hash of final content and write
        let hash = short_hash(content.as_bytes());
        let hashed_name = format!("app-{}.js", hash);
        fs::write(out_dir.join(&hashed_name), &content)?;
        fs::remove_file(&tmp_dst)?;
        manifest.insert("/assets/build/app.js".to_string(), format!("/assets/build/{}", hashed_name));
    }

    // Hash and rename font files (generated by fonts.rs) - only woff2, not ttf
    let re_font = Regex::new(r"^IBMPlexSansJP.*\.subset\.woff2$").unwrap();
    for entry in fs::read_dir(&out_dir)? {
        let p = entry?.path();
        if let Some(fname) = p.file_name().and_then(|s| s.to_str()) {
            if re_font.is_match(fname) {
                let bytes = fs::read(&p)?;
                let hash = short_hash(&bytes);
                let (stem, ext) = split_name(fname);
                let hashed_name = format!("{}-{}.{}", stem, hash, ext);
                let hashed_path = out_dir.join(&hashed_name);
                // rename original to hashed
                fs::rename(&p, &hashed_path)?;
                manifest.insert(format!("/assets/build/{}", fname), format!("/assets/build/{}", hashed_name));
            }
        }
    }

    // write manifest
    let gen_dir = PathBuf::from("static/generated");
    fs::create_dir_all(&gen_dir)?;
    let manifest_path = gen_dir.join("assets-manifest.json");
    fs::write(manifest_path, serde_json::to_string_pretty(&json!(manifest))?)?;

    Ok(())
}

fn browserslist_targets() -> Result<Targets> {
    let browsers = Browsers::from_browserslist(vec!["> 0.5%", "not dead"])?.unwrap_or_default();
    Ok(browsers.into())
}

fn minify_css_with_prefix(content: &str, targets: Targets) -> Result<String> {
    let mut sheet =
        StyleSheet::parse(content, ParserOptions::default()).map_err(|e| anyhow!(e.to_string()))?;

    sheet
        .minify(MinifyOptions {
            targets,
            ..Default::default()
        })
        .map_err(|e| anyhow!(e.to_string()))?;

    let res = sheet
        .to_css(PrinterOptions {
            minify: true,
            targets,
            ..Default::default()
        })
        .map_err(|e| anyhow!(e.to_string()))?;

    Ok(res.code)
}

fn short_hash(bytes: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(bytes);
    let res = hasher.finalize();
    hex::encode(&res)[..12].to_string()
}

fn split_name(name: &str) -> (String, String) {
    if let Some(pos) = name.rfind('.') {
        let (a, b) = name.split_at(pos);
        (a.to_string(), b.trim_start_matches('.').to_string())
    } else {
        (name.to_string(), String::new())
    }
}
